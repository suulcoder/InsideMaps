{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ExponentNotifications from \"./ExponentNotifications\";\n\nvar _emitter;\n\nvar _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  notification = _objectSpread({}, notification);\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\n\nfunction _legacyReadChannel(_x) {\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyReadChannel2() {\n  _legacyReadChannel2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee10(id) {\n    var channelString;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.prev = 0;\n            _context10.next = 3;\n            return AsyncStorage.getItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n\n          case 3:\n            channelString = _context10.sent;\n\n            if (!channelString) {\n              _context10.next = 6;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", JSON.parse(channelString));\n\n          case 6:\n            _context10.next = 10;\n            break;\n\n          case 8:\n            _context10.prev = 8;\n            _context10.t0 = _context10[\"catch\"](0);\n\n          case 10:\n            return _context10.abrupt(\"return\", null);\n\n          case 11:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[0, 8]]);\n  }));\n  return _legacyReadChannel2.apply(this, arguments);\n}\n\nfunction _legacyDeleteChannel(id) {\n  return AsyncStorage.removeItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id));\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = function () {\n    var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(callback) {\n      var keys, filteredKeys;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return AsyncStorage.getAllKeys();\n\n            case 3:\n              keys = _context.sent;\n\n              if (!(keys && keys.length)) {\n                _context.next = 8;\n                break;\n              }\n\n              filteredKeys = keys.filter(function (key) {\n                return !key.startsWith(ASYNC_STORAGE_PREFIX);\n              });\n              _context.next = 8;\n              return AsyncStorage.multiRemove(filteredKeys);\n\n            case 8:\n              callback && callback();\n              _context.next = 15;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](0);\n              callback && callback(_context.t0);\n              throw _context.t0;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 11]]);\n    }));\n\n    return function (_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction _legacySaveChannel(id, channel) {\n  return AsyncStorage.setItem(\"\".concat(ASYNC_STORAGE_PREFIX).concat(id), JSON.stringify(channel));\n}\n\nexport default {\n  _setInitialNotification: function _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  createCategoryAsync: function createCategoryAsync(categoryId, actions, previewPlaceholder) {\n    return Platform.OS === 'ios' ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder) : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync: function deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n  getExpoPushTokenAsync: function getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: function getDevicePushTokenAsync(config) {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n  createChannelAndroidAsync: function createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync: function deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \".concat(Platform.OS));\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n  presentLocalNotificationAsync: function presentLocalNotificationAsync(notification) {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n      var nativeNotification, _channel;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification);\n\n              if (!(Platform.OS !== 'android')) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 5;\n              return ExponentNotifications.presentLocalNotification(nativeNotification);\n\n            case 5:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 8:\n              if (!nativeNotification.channelId) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 11;\n              return _legacyReadChannel(nativeNotification.channelId);\n\n            case 11:\n              _channel = _context2.sent;\n\n            case 12:\n              if (!IS_USING_NEW_BINARY) {\n                _context2.next = 17;\n                break;\n              }\n\n              _legacyDeleteChannel(nativeNotification.channelId);\n\n              return _context2.abrupt(\"return\", ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel));\n\n            case 17:\n              if (_channel) {\n                nativeNotification.sound = _channel.sound;\n                nativeNotification.priority = _channel.priority;\n                nativeNotification.vibrate = _channel.vibrate;\n              }\n\n              return _context2.abrupt(\"return\", ExponentNotifications.presentLocalNotification(nativeNotification));\n\n            case 19:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n  scheduleLocalNotificationAsync: function scheduleLocalNotificationAsync(notification) {\n    var _arguments = arguments;\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n      var options, now, nativeNotification, timeAsDateObj, validOptions, _channel;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n              now = Date.now();\n\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification);\n\n              if (!options.time) {\n                _context3.next = 11;\n                break;\n              }\n\n              timeAsDateObj = null;\n\n              if (options.time && typeof options.time === 'number') {\n                timeAsDateObj = new Date(options.time);\n\n                if (timeAsDateObj.toString() === 'Invalid Date') {\n                  timeAsDateObj = null;\n                }\n              } else if (options.time && options.time instanceof Date) {\n                timeAsDateObj = options.time;\n              }\n\n              if (timeAsDateObj) {\n                _context3.next = 9;\n                break;\n              }\n\n              throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n\n            case 9:\n              if (timeAsDateObj.getTime() < now) {\n                console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n              }\n\n              options = _objectSpread({}, options, {\n                time: timeAsDateObj.getTime()\n              });\n\n            case 11:\n              if (!(options.intervalMs != null && options.repeat != null)) {\n                _context3.next = 13;\n                break;\n              }\n\n              throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n\n            case 13:\n              if (!(options.repeat != null)) {\n                _context3.next = 17;\n                break;\n              }\n\n              validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n              if (validOptions.has(options.repeat)) {\n                _context3.next = 17;\n                break;\n              }\n\n              throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n\n            case 17:\n              if (!(options.intervalMs != null)) {\n                _context3.next = 22;\n                break;\n              }\n\n              if (!(Platform.OS === 'ios')) {\n                _context3.next = 20;\n                break;\n              }\n\n              throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n\n            case 20:\n              if (!(options.intervalMs <= 0 || !Number.isInteger(options.intervalMs))) {\n                _context3.next = 22;\n                break;\n              }\n\n              throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n\n            case 22:\n              if (!(Platform.OS !== 'android')) {\n                _context3.next = 29;\n                break;\n              }\n\n              if (!options.repeat) {\n                _context3.next = 26;\n                break;\n              }\n\n              console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n              return _context3.abrupt(\"return\", ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options));\n\n            case 26:\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n            case 29:\n              if (!nativeNotification.channelId) {\n                _context3.next = 33;\n                break;\n              }\n\n              _context3.next = 32;\n              return _legacyReadChannel(nativeNotification.channelId);\n\n            case 32:\n              _channel = _context3.sent;\n\n            case 33:\n              if (!IS_USING_NEW_BINARY) {\n                _context3.next = 38;\n                break;\n              }\n\n              _legacyDeleteChannel(nativeNotification.channelId);\n\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel));\n\n            case 38:\n              if (_channel) {\n                nativeNotification.sound = _channel.sound;\n                nativeNotification.priority = _channel.priority;\n                nativeNotification.vibrate = _channel.vibrate;\n              }\n\n              return _context3.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n            case 40:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n  dismissNotificationAsync: function dismissNotificationAsync(notificationId) {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (ExponentNotifications.dismissNotification) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n\n            case 2:\n              _context4.next = 4;\n              return ExponentNotifications.dismissNotification(notificationId);\n\n            case 4:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  },\n  dismissAllNotificationsAsync: function dismissAllNotificationsAsync() {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee5() {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (ExponentNotifications.dismissAllNotifications) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n\n            case 2:\n              _context5.next = 4;\n              return ExponentNotifications.dismissAllNotifications();\n\n            case 4:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }))();\n  },\n  cancelScheduledNotificationAsync: function cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n  cancelAllScheduledNotificationsAsync: function cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n  addListener: function addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(function () {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync: function getBadgeNumberAsync() {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee6() {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (ExponentNotifications.getBadgeNumberAsync) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\", 0);\n\n            case 2:\n              return _context6.abrupt(\"return\", ExponentNotifications.getBadgeNumberAsync());\n\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }))();\n  },\n  setBadgeNumberAsync: function setBadgeNumberAsync(number) {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee7() {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (ExponentNotifications.setBadgeNumberAsync) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n\n            case 2:\n              return _context7.abrupt(\"return\", ExponentNotifications.setBadgeNumberAsync(number));\n\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }))();\n  },\n  scheduleNotificationWithCalendarAsync: function scheduleNotificationWithCalendarAsync(notification) {\n    var _arguments2 = arguments;\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee8() {\n      var options, areOptionsValid, nativeNotification;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n              areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n\n              if (areOptionsValid) {\n                _context8.next = 4;\n                break;\n              }\n\n              throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n\n            case 4:\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification);\n              return _context8.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options));\n\n            case 7:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }))();\n  },\n  scheduleNotificationWithTimerAsync: function scheduleNotificationWithTimerAsync(notification, options) {\n    return _asyncToGenerator(_regeneratorRuntime.mark(function _callee9() {\n      var nativeNotification;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(options.interval < 1)) {\n                _context9.next = 2;\n                break;\n              }\n\n              throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n\n            case 2:\n              _validateNotification(notification);\n\n              nativeNotification = _processNotification(notification);\n              return _context9.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options));\n\n            case 5:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }))();\n  }\n};\n\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":{"version":3,"sources":["../../src/Notifications/Notifications.ts"],"names":[],"mappings":";;;;;;;;;AAAA,SAAS,UAAT,EAAqB,qBAArB,EAA4C,mBAA5C,QAAuE,kBAAvE;AACA,OAAO,SAAP,MAAsB,gBAAtB;AACA,SAAS,YAAT,QAAgD,WAAhD;AACA,OAAO,SAAP,MAAsB,WAAtB;;;AAGA,OAAO,qBAAP;;AAQA,IAAI,QAAJ;;AACA,IAAI,oBAAJ;;AAEA,SAAS,iBAAT,GAA0B;AACxB,MAAI,CAAC,QAAL,EAAe;AACb,IAAA,QAAQ,GAAG,IAAI,YAAJ,EAAX;AACA,IAAA,qBAAqB,CAAC,WAAtB,CAAkC,uBAAlC,EAA2D,gBAA3D;AACD;AACF;;AAED,OAAM,SAAU,gBAAV,CAA2B,YAA3B,EAAuC;AAC3C,MAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AACpC,IAAA,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAAf;AACD;;AAGD,EAAA,YAAY,qBAAQ,YAAR,CAAZ;;AAEA,MAAI,OAAO,YAAY,CAAC,IAApB,KAA6B,QAAjC,EAA2C;AACzC,QAAI;AACF,MAAA,YAAY,CAAC,IAAb,GAAoB,IAAI,CAAC,KAAL,CAAW,YAAY,CAAC,IAAxB,CAApB;AACD,KAFD,CAEE,OAAO,CAAP,EAAU,CAEX;AACF;;AAED,EAAA,QAAQ,CAAC,IAAT,CAAc,cAAd,EAA8B,YAA9B;AACD;;AAED,SAAS,oBAAT,CAA8B,YAA9B,EAA0C;AACxC,EAAA,YAAY,GAAG,SAAc,EAAd,EAAkB,YAAlB,CAAf;;AAEA,MAAI,CAAC,YAAY,CAAC,IAAlB,EAAwB;AACtB,IAAA,YAAY,CAAC,IAAb,GAAoB,EAApB;AACD;;AAED,MAAI,YAAY,CAAC,cAAb,CAA4B,OAA5B,CAAJ,EAA0C;AACxC,WAAO,YAAY,CAAC,KAApB;AACD;;AAGD,MAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB,QAAI,YAAY,CAAC,OAAjB,EAA0B;AACxB,aAAO,YAAY,CAAC,OAApB;AACD;;AAED,QAAI,YAAY,CAAC,GAAjB,EAAsB;AACpB,MAAA,YAAY,GAAG,SAAc,YAAd,EAA4B,YAAY,CAAC,GAAzC,CAAf;AACA,MAAA,YAAY,CAAC,IAAb,CAAkB,oBAAlB,GAAyC,YAAY,CAAC,GAAb,CAAiB,oBAA1D;AACA,aAAO,YAAY,CAAC,GAApB;AACD;AACF;;AAID,MAAI,QAAQ,CAAC,EAAT,KAAgB,SAApB,EAA+B;AAC7B,QAAI,YAAY,CAAC,GAAjB,EAAsB;AACpB,aAAO,YAAY,CAAC,GAApB;AACD;;AAED,QAAI,YAAY,CAAC,OAAjB,EAA0B;AACxB,MAAA,YAAY,GAAG,SAAc,YAAd,EAA4B,YAAY,CAAC,OAAzC,CAAf;AACA,aAAO,YAAY,CAAC,OAApB;AACD;AACF;;AAED,SAAO,YAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,YAA/B,EAA2C;AACzC,MAAI,QAAQ,CAAC,EAAT,KAAgB,KAApB,EAA2B;AACzB,IAAA,SAAS,CACP,CAAC,CAAC,YAAY,CAAC,KAAf,IAAwB,CAAC,CAAC,YAAY,CAAC,IADhC,EAEP,4DAFO,CAAT;AAID,GALD,MAKO,IAAI,QAAQ,CAAC,EAAT,KAAgB,SAApB,EAA+B;AACpC,IAAA,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,KAAhB,EAAuB,gDAAvB,CAAT;AACD;AACF;;AAED,IAAI,oBAAoB,GAAG,0BAA3B;AAGA,IAAM,mBAAmB,GACvB,qBAAqB,IAAI,OAAO,qBAAqB,CAAC,aAA7B,KAA+C,UAD1E;;SAGe,kB;;;;;mEAAf,mBAAkC,EAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAE8B,YAAY,CAAC,OAAb,WAAwB,oBAAxB,SAA+C,EAA/C,EAF9B;;AAAA;AAEQ,YAAA,aAFR;;AAAA,iBAGQ,aAHR;AAAA;AAAA;AAAA;;AAAA,+CAIa,IAAI,CAAC,KAAL,CAAW,aAAX,CAJb;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAOS,IAPT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAUA,SAAS,oBAAT,CAA8B,EAA9B,EAAwC;AACtC,SAAO,YAAY,CAAC,UAAb,WAA2B,oBAA3B,SAAkD,EAAlD,EAAP;AACD;;AAED,IAAI,QAAQ,CAAC,EAAT,KAAgB,SAApB,EAA+B;AAC7B,EAAA,YAAY,CAAC,KAAb;AAAA,0DAAqB,iBAAe,QAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAEA,YAAY,CAAC,UAAb,EAFA;;AAAA;AAEb,cAAA,IAFa;;AAAA,oBAGb,IAAI,IAAI,IAAI,CAAC,MAHA;AAAA;AAAA;AAAA;;AAIX,cAAA,YAJW,GAII,IAAI,CAAC,MAAL,CAAY,UAAA,GAAG;AAAA,uBAAI,CAAC,GAAG,CAAC,UAAJ,CAAe,oBAAf,CAAL;AAAA,eAAf,CAJJ;AAAA;AAAA,qBAKT,YAAY,CAAC,WAAb,CAAyB,YAAzB,CALS;;AAAA;AAOjB,cAAA,QAAQ,IAAI,QAAQ,EAApB;AAPiB;AAAA;;AAAA;AAAA;AAAA;AASjB,cAAA,QAAQ,IAAI,QAAQ,aAApB;AATiB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAArB;;AAAA;AAAA;AAAA;AAAA;AAaD;;AAID,SAAS,kBAAT,CAA4B,EAA5B,EAAwC,OAAxC,EAAwD;AACtD,SAAO,YAAY,CAAC,OAAb,WAAwB,oBAAxB,SAA+C,EAA/C,GAAqD,IAAI,CAAC,SAAL,CAAe,OAAf,CAArD,CAAP;AACD;;AAED,eAAe;AAEb,EAAA,uBAFa,mCAEW,YAFX,EAEqC;AAChD,IAAA,oBAAoB,GAAG,YAAvB;AACD,GAJY;AAOb,EAAA,mBAPa,+BAQX,UARW,EASX,OATW,EAUX,kBAVW,EAUgB;AAE3B,WAAO,QAAQ,CAAC,EAAT,KAAgB,KAAhB,GACH,qBAAqB,CAAC,mBAAtB,CAA0C,UAA1C,EAAsD,OAAtD,EAA+D,kBAA/D,CADG,GAEH,qBAAqB,CAAC,mBAAtB,CAA0C,UAA1C,EAAsD,OAAtD,CAFJ;AAGD,GAfY;AAiBb,EAAA,mBAjBa,+BAiBO,UAjBP,EAiByB;AACpC,WAAO,qBAAqB,CAAC,mBAAtB,CAA0C,UAA1C,CAAP;AACD,GAnBY;AAsBb,EAAA,qBAtBa,mCAsBQ;AACnB,QAAI,CAAC,qBAAqB,CAAC,yBAA3B,EAAsD;AACpD,YAAM,IAAI,mBAAJ,CAAwB,oBAAxB,EAA8C,uBAA9C,CAAN;AACD;;AACD,QAAI,CAAC,SAAS,CAAC,QAAf,EAAyB;AACvB,YAAM,IAAI,KAAJ,0DAAN;AACD;;AACD,WAAO,qBAAqB,CAAC,yBAAtB,EAAP;AACD,GA9BY;AAgCb,EAAA,uBAAuB,EAAE,iCAAC,MAAD,EAEqB;AAC5C,QAAI,CAAC,qBAAqB,CAAC,uBAA3B,EAAoD;AAClD,YAAM,IAAI,mBAAJ,CAAwB,oBAAxB,EAA8C,yBAA9C,CAAN;AACD;;AACD,WAAO,qBAAqB,CAAC,uBAAtB,CAA8C,MAAM,IAAI,EAAxD,CAAP;AACD,GAvCY;AAyCb,EAAA,yBAzCa,qCAyCa,EAzCb,EAyCyB,OAzCzB,EAyCyC;AACpD,QAAI,QAAQ,CAAC,EAAT,KAAgB,SAApB,EAA+B;AAC7B,MAAA,OAAO,CAAC,IAAR,2DAAgE,QAAQ,CAAC,EAAzE;AACA,aAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAGD,QAAI,CAAC,mBAAL,EAA0B;AACxB,aAAO,kBAAkB,CAAC,EAAD,EAAK,OAAL,CAAzB;AACD;;AACD,WAAO,qBAAqB,CAAC,aAAtB,CAAoC,EAApC,EAAwC,OAAxC,CAAP;AACD,GApDY;AAsDb,EAAA,yBAtDa,qCAsDa,EAtDb,EAsDuB;AAClC,QAAI,QAAQ,CAAC,EAAT,KAAgB,SAApB,EAA+B;AAC7B,MAAA,OAAO,CAAC,IAAR,2DAAgE,QAAQ,CAAC,EAAzE;AACA,aAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAGD,QAAI,CAAC,mBAAL,EAA0B;AACxB,aAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AACD,WAAO,qBAAqB,CAAC,aAAtB,CAAoC,EAApC,CAAP;AACD,GAjEY;AAoEP,EAAA,6BApEO,yCAqEX,YArEW,EAqEoB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAE/B,cAAA,qBAAqB,CAAC,YAAD,CAArB;;AACI,cAAA,kBAH2B,GAGN,oBAAoB,CAAC,YAAD,CAHd;;AAAA,oBAK3B,QAAQ,CAAC,EAAT,KAAgB,SALW;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAMhB,qBAAqB,CAAC,wBAAtB,CAA+C,kBAA/C,CANgB;;AAAA;AAAA;;AAAA;AAAA,mBASzB,kBAAkB,CAAC,SATM;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAUV,kBAAkB,CAAC,kBAAkB,CAAC,SAApB,CAVR;;AAAA;AAU3B,cAAA,QAV2B;;AAAA;AAAA,mBAazB,mBAbyB;AAAA;AAAA;AAAA;;AAe3B,cAAA,oBAAoB,CAAC,kBAAkB,CAAC,SAApB,CAApB;;AAf2B,gDAgBpB,qBAAqB,CAAC,mCAAtB,CACL,kBADK,EAEL,QAFK,CAhBoB;;AAAA;AAuB3B,kBAAI,QAAJ,EAAc;AACZ,gBAAA,kBAAkB,CAAC,KAAnB,GAA2B,QAAQ,CAAC,KAApC;AACA,gBAAA,kBAAkB,CAAC,QAAnB,GAA8B,QAAQ,CAAC,QAAvC;AACA,gBAAA,kBAAkB,CAAC,OAAnB,GAA6B,QAAQ,CAAC,OAAtC;AACD;;AA3B0B,gDA4BpB,qBAAqB,CAAC,wBAAtB,CAA+C,kBAA/C,CA5BoB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BhC,GApGY;AAuGP,EAAA,8BAvGO,0CAwGX,YAxGW,EA6GL;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAJN,cAAA,OAIM,0EAAF,EAAE;AAIA,cAAA,GAJA,GAIM,IAAI,CAAC,GAAL,EAJN;;AAON,cAAA,qBAAqB,CAAC,YAAD,CAArB;;AACI,cAAA,kBARE,GAQmB,oBAAoB,CAAC,YAAD,CARvC;;AAAA,mBAWF,OAAO,CAAC,IAXN;AAAA;AAAA;AAAA;;AAYA,cAAA,aAZA,GAY6B,IAZ7B;;AAaJ,kBAAI,OAAO,CAAC,IAAR,IAAgB,OAAO,OAAO,CAAC,IAAf,KAAwB,QAA5C,EAAsD;AACpD,gBAAA,aAAa,GAAG,IAAI,IAAJ,CAAS,OAAO,CAAC,IAAjB,CAAhB;;AACA,oBAAI,aAAa,CAAC,QAAd,OAA6B,cAAjC,EAAiD;AAC/C,kBAAA,aAAa,GAAG,IAAhB;AACD;AACF,eALD,MAKO,IAAI,OAAO,CAAC,IAAR,IAAgB,OAAO,CAAC,IAAR,YAAwB,IAA5C,EAAkD;AACvD,gBAAA,aAAa,GAAG,OAAO,CAAC,IAAxB;AACD;;AApBG,kBAuBC,aAvBD;AAAA;AAAA;AAAA;;AAAA,oBAwBI,IAAI,KAAJ,yJAxBJ;;AAAA;AA+BJ,kBAAI,aAAa,CAAC,OAAd,KAA0B,GAA9B,EAAmC;AACjC,gBAAA,OAAO,CAAC,IAAR;AAGD;;AAED,cAAA,OAAO,qBACF,OADE;AAEL,gBAAA,IAAI,EAAE,aAAa,CAAC,OAAd;AAFD,gBAAP;;AArCI;AAAA,oBA2CF,OAAO,CAAC,UAAR,IAAsB,IAAtB,IAA8B,OAAO,CAAC,MAAR,IAAkB,IA3C9C;AAAA;AAAA;AAAA;;AAAA,oBA4CE,IAAI,KAAJ,wEA5CF;;AAAA;AAAA,oBAgDF,OAAO,CAAC,MAAR,IAAkB,IAhDhB;AAAA;AAAA;AAAA;;AAiDE,cAAA,YAjDF,GAiDiB,IAAI,GAAJ,CAAQ,CAAC,QAAD,EAAW,MAAX,EAAmB,KAAnB,EAA0B,MAA1B,EAAkC,OAAlC,EAA2C,MAA3C,CAAR,CAjDjB;;AAAA,kBAkDC,YAAY,CAAC,GAAb,CAAiB,OAAO,CAAC,MAAzB,CAlDD;AAAA;AAAA;AAAA;;AAAA,oBAmDI,IAAI,KAAJ,yGAnDJ;;AAAA;AAAA,oBAyDF,OAAO,CAAC,UAAR,IAAsB,IAzDpB;AAAA;AAAA;AAAA;;AAAA,oBA0DA,QAAQ,CAAC,EAAT,KAAgB,KA1DhB;AAAA;AAAA;AAAA;;AAAA,oBA2DI,IAAI,KAAJ,qDA3DJ;;AAAA;AAAA,oBA8DA,OAAO,CAAC,UAAR,IAAsB,CAAtB,IAA2B,CAAC,MAAM,CAAC,SAAP,CAAiB,OAAO,CAAC,UAAzB,CA9D5B;AAAA;AAAA;AAAA;;AAAA,oBA+DI,IAAI,KAAJ,gFA/DJ;;AAAA;AAAA,oBAqEF,QAAQ,CAAC,EAAT,KAAgB,SArEd;AAAA;AAAA;AAAA;;AAAA,mBAsEA,OAAO,CAAC,MAtER;AAAA;AAAA;AAAA;;AAuEF,cAAA,OAAO,CAAC,IAAR,CACE,8HADF;AAvEE,gDA0EK,qBAAqB,CAAC,wCAAtB,CACL,kBADK,EAEL,OAFK,CA1EL;;AAAA;AAAA,gDAgFG,qBAAqB,CAAC,yBAAtB,CAAgD,kBAAhD,EAAoE,OAApE,CAhFH;;AAAA;AAAA,mBAmFA,kBAAkB,CAAC,SAnFnB;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAoFe,kBAAkB,CAAC,kBAAkB,CAAC,SAApB,CApFjC;;AAAA;AAoFF,cAAA,QApFE;;AAAA;AAAA,mBAuFA,mBAvFA;AAAA;AAAA;AAAA;;AAyFF,cAAA,oBAAoB,CAAC,kBAAkB,CAAC,SAApB,CAApB;;AAzFE,gDA0FK,qBAAqB,CAAC,oCAAtB,CACL,kBADK,EAEL,OAFK,EAGL,QAHK,CA1FL;;AAAA;AAkGF,kBAAI,QAAJ,EAAc;AACZ,gBAAA,kBAAkB,CAAC,KAAnB,GAA2B,QAAQ,CAAC,KAApC;AACA,gBAAA,kBAAkB,CAAC,QAAnB,GAA8B,QAAQ,CAAC,QAAvC;AACA,gBAAA,kBAAkB,CAAC,OAAnB,GAA6B,QAAQ,CAAC,OAAtC;AACD;;AAtGC,gDAuGK,qBAAqB,CAAC,yBAAtB,CAAgD,kBAAhD,EAAoE,OAApE,CAvGL;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0GP,GAvNY;AA0NP,EAAA,wBA1NO,oCA0NkB,cA1NlB,EA0NqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAC3D,qBAAqB,CAAC,mBADqC;AAAA;AAAA;AAAA;;AAAA,oBAExD,IAAI,mBAAJ,CAAwB,oBAAxB,EAA8C,qBAA9C,CAFwD;;AAAA;AAAA;AAAA,qBAInD,qBAAqB,CAAC,mBAAtB,CAA0C,cAA1C,CAJmD;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKjE,GA/NY;AAkOP,EAAA,4BAlOO,0CAkOqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAC3B,qBAAqB,CAAC,uBADK;AAAA;AAAA;AAAA;;AAAA,oBAExB,IAAI,mBAAJ,CAAwB,oBAAxB,EAA8C,yBAA9C,CAFwB;;AAAA;AAAA;AAAA,qBAInB,qBAAqB,CAAC,uBAAtB,EAJmB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKjC,GAvOY;AA0Ob,EAAA,gCA1Oa,4CA0OoB,cA1OpB,EA0OuD;AAClE,QAAI,QAAQ,CAAC,EAAT,KAAgB,SAAhB,IAA6B,OAAO,cAAP,KAA0B,QAA3D,EAAqE;AACnE,aAAO,qBAAqB,CAAC,4CAAtB,CAAmE,cAAnE,CAAP;AACD;;AACD,WAAO,qBAAqB,CAAC,gCAAtB,CAAuD,cAAvD,CAAP;AACD,GA/OY;AAkPb,EAAA,oCAlPa,kDAkPuB;AAClC,WAAO,qBAAqB,CAAC,oCAAtB,EAAP;AACD,GApPY;AAuPb,EAAA,WAvPa,uBAuPD,QAvPC,EAuPgD;AAC3D,IAAA,iBAAiB;;AAEjB,QAAI,oBAAJ,EAA0B;AACxB,UAAM,mBAAmB,GAAG,oBAA5B;AACA,MAAA,oBAAoB,GAAG,IAAvB;AACA,MAAA,UAAU,CAAC,YAAK;AACd,QAAA,gBAAgB,CAAC,mBAAD,CAAhB;AACD,OAFS,EAEP,CAFO,CAAV;AAGD;;AAED,WAAO,QAAQ,CAAC,WAAT,CAAqB,cAArB,EAAqC,QAArC,CAAP;AACD,GAnQY;AAqQP,EAAA,mBArQO,iCAqQY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAClB,qBAAqB,CAAC,mBADJ;AAAA;AAAA;AAAA;;AAAA,gDAEd,CAFc;;AAAA;AAAA,gDAIhB,qBAAqB,CAAC,mBAAtB,EAJgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKxB,GA1QY;AA4QP,EAAA,mBA5QO,+BA4Qa,MA5Qb,EA4Q2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACjC,qBAAqB,CAAC,mBADW;AAAA;AAAA;AAAA;;AAAA,oBAE9B,IAAI,mBAAJ,CAAwB,oBAAxB,EAA8C,qBAA9C,CAF8B;;AAAA;AAAA,gDAI/B,qBAAqB,CAAC,mBAAtB,CAA0C,MAA1C,CAJ+B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKvC,GAjRY;AAmRP,EAAA,qCAnRO,iDAoRX,YApRW,EA8RL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AATN,cAAA,OASM,6EAAF,EAAE;AAEA,cAAA,eAFA,GAGJ,CAAC,OAAO,CAAC,KAAR,IAAiB,IAAjB,IAAyB,kBAAkB,CAAC,OAAO,CAAC,KAAT,EAAgB,CAAhB,EAAmB,EAAnB,CAA5C,MACC,OAAO,CAAC,GAAR,IAAe,IAAf,IAAuB,kBAAkB,CAAC,OAAO,CAAC,GAAT,EAAc,CAAd,EAAiB,EAAjB,CAD1C,MAEC,OAAO,CAAC,IAAR,IAAgB,IAAhB,IAAwB,kBAAkB,CAAC,OAAO,CAAC,IAAT,EAAe,CAAf,EAAkB,EAAlB,CAF3C,MAGC,OAAO,CAAC,MAAR,IAAkB,IAAlB,IAA0B,kBAAkB,CAAC,OAAO,CAAC,MAAT,EAAiB,CAAjB,EAAoB,EAApB,CAH7C,MAIC,OAAO,CAAC,MAAR,IAAkB,IAAlB,IAA0B,kBAAkB,CAAC,OAAO,CAAC,MAAT,EAAiB,CAAjB,EAAoB,EAApB,CAJ7C,MAKC,OAAO,CAAC,OAAR,IAAmB,IAAnB,IAA2B,kBAAkB,CAAC,OAAO,CAAC,OAAT,EAAkB,CAAlB,EAAqB,CAArB,CAL9C,MAMC,OAAO,CAAC,OAAR,IAAmB,IAAnB,IAA2B,OAAO,CAAC,GAAR,IAAe,IAN3C,CAHI;;AAAA,kBAWD,eAXC;AAAA;AAAA;AAAA;;AAAA,oBAYE,IAAI,UAAJ,CACJ,eADI,EAEJ,uEAFI,CAZF;;AAAA;AAkBN,cAAA,qBAAqB,CAAC,YAAD,CAArB;;AACI,cAAA,kBAnBE,GAmBmB,oBAAoB,CAAC,YAAD,CAnBvC;AAAA,gDAqBC,qBAAqB,CAAC,gCAAtB,CAAuD,kBAAvD,EAA2E,OAA3E,CArBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsBP,GApTY;AAsTP,EAAA,kCAtTO,8CAuTX,YAvTW,EAwTX,OAxTW,EA2TV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAEG,OAAO,CAAC,QAAR,GAAmB,CAFtB;AAAA;AAAA;AAAA;;AAAA,oBAGO,IAAI,UAAJ,CAAe,eAAf,EAAgC,kCAAhC,CAHP;;AAAA;AAMD,cAAA,qBAAqB,CAAC,YAAD,CAArB;;AACI,cAAA,kBAPH,GAOwB,oBAAoB,CAAC,YAAD,CAP5C;AAAA,gDASM,qBAAqB,CAAC,6BAAtB,CAAoD,kBAApD,EAAwE,OAAxE,CATN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUF;AArUY,CAAf;;AAwUA,SAAS,kBAAT,CAA4B,QAA5B,EAA8C,GAA9C,EAA2D,GAA3D,EAAsE;AACpE,SAAO,QAAQ,IAAI,GAAZ,IAAmB,QAAQ,IAAI,GAAtC;AACD","sourcesContent":["import { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { AsyncStorage, Platform } from 'react-native';\n\nimport ExponentNotifications from './ExponentNotifications';\nimport {\n  Notification,\n  LocalNotification,\n  Channel,\n  ActionType,\n  LocalNotificationId,\n} from './Notifications.types';\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nlet ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nconst IS_USING_NEW_BINARY =\n  ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    let channelString = await AsyncStorage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return AsyncStorage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  AsyncStorage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      let keys = await AsyncStorage.getAllKeys();\n      if (keys && keys.length) {\n        let filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await AsyncStorage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return AsyncStorage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(\n    categoryId: string,\n    actions: ActionType[],\n    previewPlaceholder?: string\n  ): Promise<void> {\n    return Platform.OS === 'ios'\n      ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder)\n      : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> => {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`deleteChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    if (Platform.OS !== 'android') {\n      return await ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'android') {\n      if (options.repeat) {\n        console.warn(\n          'Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.'\n        );\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(\n          nativeNotification,\n          options\n        );\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (!ExponentNotifications.dismissNotification) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n    }\n    return await ExponentNotifications.dismissNotification(notificationId);\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (!ExponentNotifications.dismissAllNotifications) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n    }\n    return await ExponentNotifications.dismissAllNotifications();\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: (notification: Notification) => unknown): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n\n  async scheduleNotificationWithCalendarAsync(\n    notification: LocalNotification,\n    options: {\n      year?: number;\n      month?: number;\n      hour?: number;\n      day?: number;\n      minute?: number;\n      second?: number;\n      weekDay?: number;\n      repeat?: boolean;\n    } = {}\n  ): Promise<string> {\n    const areOptionsValid: boolean =\n      (options.month == null || isInRangeInclusive(options.month, 1, 12)) &&\n      (options.day == null || isInRangeInclusive(options.day, 1, 31)) &&\n      (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) &&\n      (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) &&\n      (options.second == null || isInRangeInclusive(options.second, 0, 59)) &&\n      (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) &&\n      (options.weekDay == null || options.day == null);\n\n    if (!areOptionsValid) {\n      throw new CodedError(\n        'WRONG_OPTIONS',\n        'Options in scheduleNotificationWithCalendarAsync call were incorrect!'\n      );\n    }\n\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options);\n  },\n\n  async scheduleNotificationWithTimerAsync(\n    notification: LocalNotification,\n    options: {\n      interval: number;\n      repeat?: boolean;\n    }\n  ): Promise<string> {\n    if (options.interval < 1) {\n      throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n    }\n\n    _validateNotification(notification);\n    let nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options);\n  },\n};\n\nfunction isInRangeInclusive(variable: number, min: number, max: number): boolean {\n  return variable >= min && variable <= max;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}