{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { combineReducers } from 'redux';\nimport omit from 'lodash/omit';\nimport * as types from \"../types/map\";\n\nvar byId = function byId() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.types) {\n    case types.CREATE_MAP_STARTED:\n      {\n        var newState = _objectSpread({}, state);\n\n        newState[action.payload.id] = _objectSpread({}, action.payload, {\n          isConfirmed: false\n        });\n        return newState;\n      }\n\n    case types.CREATE_MAP_COMPLETED:\n      {\n        var _action$payload = action.payload,\n            oldId = _action$payload.oldId,\n            map = _action$payload.map;\n\n        var _newState = omit(state, oldId);\n\n        _newState[map.id] = _objectSpread({}, map, {\n          isConfirmed: true\n        });\n        return _newState;\n      }\n\n    case types.FETCH_MAP_COMPLETED:\n      {\n        var _action$payload2 = action.payload,\n            entities = _action$payload2.entities,\n            _order = _action$payload2.order;\n\n        var _newState2 = _objectSpread({}, state);\n\n        _order.forEach(function (id) {\n          _newState2[id] = _objectSpread({}, entities[id], {\n            isConfirmed: true\n          });\n          return _newState2;\n        });\n      }\n\n    case types.REMOVE_MAP_STARTED:\n      {\n        return omit(state, action.payload.id);\n      }\n  }\n\n  return state;\n};\n\nvar order = function order() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.types) {\n    case types.CREATE_MAP_STARTED:\n      {\n        return [].concat(_toConsumableArray(state), [action.payload.id]);\n      }\n\n    case types.CREATE_MAP_COMPLETED:\n      {\n        var _action$payload3 = action.payload,\n            oldId = _action$payload3.oldId,\n            map = _action$payload3.map;\n        return state.map(function (id) {\n          return id === oldId ? map.id : id;\n        });\n      }\n\n    case types.FETCH_MAP_COMPLETED:\n      {\n        return [].concat(_toConsumableArray(state), _toConsumableArray(action.payload.order));\n      }\n\n    case types.REMOVE_MAP_STARTED:\n      {\n        return state.filter(function (id) {\n          return id !== action.payload.id;\n        });\n      }\n  }\n\n  return state;\n};\n\nvar isFetching = function isFetching() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case types.FETCH_MAP_COMPLETED:\n      {\n        return false;\n      }\n\n    case types.FETCH_MAP_STARTED:\n      {\n        return true;\n      }\n\n    case types.FETCH_MAP_FAILED:\n      {\n        return false;\n      }\n  }\n\n  return state;\n};\n\nvar error = function error() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case types.CREATE_MAP_FAILED:\n      {\n        return action.payload.error;\n      }\n\n    case types.FETCH_MAP_FAILED:\n      {\n        return action.payload.error;\n      }\n\n    case types.REMOVE_MAP_FAILED:\n      {\n        return action.payload.error;\n      }\n  }\n\n  return state;\n};\n\nexport default combineReducers({\n  byId: byId,\n  order: order,\n  isFetching: isFetching,\n  error: error\n});\nexport var getMap = function getMap(state, id) {\n  return state.byId[id];\n};\nexport var getMaps = function getMaps(state) {\n  return state.order.map(function (id) {\n    return getMap(state, id);\n  });\n};\nexport var isFetchingMap = function isFetchingMap(state) {\n  return state.isFetching;\n};\nexport var getFetchingMapError = function getFetchingMapError(state) {\n  return state.error;\n};","map":{"version":3,"sources":["/home/roberto/Desktop/UVG 2020/INGENIERIA/InsideMaps/src/reducers/map.js"],"names":["combineReducers","omit","types","byId","state","action","CREATE_MAP_STARTED","newState","payload","id","isConfirmed","CREATE_MAP_COMPLETED","oldId","map","FETCH_MAP_COMPLETED","entities","order","forEach","REMOVE_MAP_STARTED","filter","isFetching","type","FETCH_MAP_STARTED","FETCH_MAP_FAILED","error","CREATE_MAP_FAILED","REMOVE_MAP_FAILED","getMap","getMaps","isFetchingMap","getFetchingMapError"],"mappings":"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","sourcesContent":["import { combineReducers } from 'redux';\nimport omit from 'lodash/omit';\n\nimport * as types from '../types/map';\n\n\n\nconst byId = (state = {}, action) => {\n  switch(action.types){\n    case types.CREATE_MAP_STARTED: {\n      const newState = {...state};\n      newState[action.payload.id] = {\n        ...action.payload,\n        isConfirmed: false,\n      }\n      return newState;\n    }\n    case types.CREATE_MAP_COMPLETED: {\n      const { oldId, map } = action.payload;\n      const newState = omit(state, oldId);\n      newState[map.id] = {\n        ...map, \n        isConfirmed: true,\n      }\n      return newState;\n    }\n    case types.FETCH_MAP_COMPLETED: {\n      const { entities, order } = action.payload;\n      const newState = {...state};\n      order.forEach(id =>{\n        newState[id] = {\n        ...entities[id],\n        isConfirmed: true,\n        }\n      return newState;\n      });\n    }\n    case types.REMOVE_MAP_STARTED: {\n      return omit(state, action.payload.id);\n    }\n  }\n  return state;\n};\n\nconst order = (state=[], action) => {\n  switch(action.types){\n    case types.CREATE_MAP_STARTED: {\n      return [...state, action.payload.id];\n    }\n    case types.CREATE_MAP_COMPLETED: {\n      const { oldId, map } = action.payload;\n      return state.map(id => id === oldId ? map.id : id);\n    }\n    case types.FETCH_MAP_COMPLETED:{\n      return [...state, ...action.payload.order];\n    }\n    case types.REMOVE_MAP_STARTED: {\n      return state.filter(id => id !== action.payload.id);\n    }\n  }\n  return state;\n};\n\nconst isFetching = (state=false, action) => {\n  switch(action.type){\n    case types.FETCH_MAP_COMPLETED: {\n      return false;\n    }\n    case types.FETCH_MAP_STARTED: {\n      return true;\n    }\n    case types.FETCH_MAP_FAILED: {\n      return false;\n    }  \n  }\n  return state\n}\n\nconst error = (state=null, action) => {\n  switch(action.type){\n    case types.CREATE_MAP_FAILED: {\n      return action.payload.error;\n    }\n    case types.FETCH_MAP_FAILED: {\n      return action.payload.error;\n    }\n    case types.REMOVE_MAP_FAILED: {\n      return action.payload.error;\n    }\n  }\n  return state;\n};\n\nexport default combineReducers({\n  byId,\n  order,\n  isFetching,\n  error,\n});\n\n//selectors\nexport const getMap = (state, id) => state.byId[id];\nexport const getMaps = state => state.order.map(id => getMap(state, id));\nexport const isFetchingMap = state => state.isFetching;\nexport const getFetchingMapError = state => state.error;\n"]},"metadata":{},"sourceType":"module"}